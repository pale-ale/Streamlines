%!TEX root = ../Thesis.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Results}
\label[section]{sec:results}
\begin{figure}[ht]
    \centering
    \begin{subfigure}{.242\textwidth}
        \centering
        \includegraphics[scale=.067]{figures/Results/Trivial/SinkVectorPlot.png}
        \caption{}
    \end{subfigure}
    \begin{subfigure}{.24\textwidth}
        \centering
        \includegraphics[scale=.067]{figures/Results/Medium/GyroVectorPlot.png}
        \caption{}
    \end{subfigure}
    \begin{subfigure}{.48\textwidth}
        \centering
        \includegraphics[scale=.0672]{figures/Results/HotRoom/HotRoomVectorPlot.png}
        \caption{}
    \end{subfigure}
    \caption{
        Vector plots of fields used to compare different algorithms in this chapter.
        (a) A trivial sink $u(x,y,t)=(x-t, y-t)$.
        (b) Double gyre.
        (c) HotRoom dataset.
    }
    \label[figure]{fig:resultsoverview}
\end{figure}
In this chapter, we start by running the full algorithm on various datasets while
discussing the different outcomes compared to other strategies.
Then, we show some performance metrics and the hardware configuration.
We finish this chapter with limitations and some ideas for future work regarding the functionality
and choice of parameters of our algorithm.
For the entirety of this chapter, we use $0.5 \cdot L_s$ as the radius of $L_t$
and a temporal weight of $\alpha=0.5$, unless stated otherwise.

\section{Comparing Behaviors for Different Fields}
The comparisons for the various fields are made between Turk and Banks' algorithm without coherence,
a slightly modified version that simply redraws the lines at their seed for subsequent frames,
and our implementation using coaxing and shattering.
We start this section with three simple fields visualized using straight lines,
continue with the other fields already used in this thesis, and conclude with images from a 60 x 30 dataset.
In \Cref{fig:resultsoverview}, we see one field from each group:
(a) as a base case, (b) to compare behavior on a smaller scale, and (c) as the final benchmark.
\newpage

\begin{figure}[ht]
    \centering
    \begin{subfigure}{\textwidth}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/StraightLines.png}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/StraightTB.png}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/StraightConst2.png}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/StraightOurs2.png}
            \caption{}
        \end{subfigure}
    \end{subfigure}
    \caption{
        (a) The initial state.
        (b--d) Footprints for the field $u_1(x, y) = (1,0)^T$ generated by
        (b) the base algorithm, (c) the constant algorithm, (d) our implementation.
        Seeds are drawn in magenta.
    }
    \label[figure]{fig:trivialresults1}
\end{figure}


\subsection{Baseline Fields}
\begin{leftbar}
    \textbf{Note}: We refer to the implementation by Turk and Banks as the \textit{base algorithm},
    and call the modified version placing constant seeds the \textit{constant algorithm}.
    Seeds, if applicable, are drawn in magenta.
\end{leftbar}
We compare streamline placements for three baseline cases exhibiting inherently trivial coherence, no coherence, and partial coherence.
We start with the first case by using a constant field $u_1(x, y) = (1,0)$, which is seen in \Cref{fig:trivialresults1}.
Coherence is trivially achieved due to it being steady, i.e. time coherence is already achieved by not moving the seeds.

One notable difference in \Cref{fig:trivialresults1}(b) compared to (a) and (c) is the removal of a line in the lower half for the base algorithm.
This happens due to the lines being added and removed at random, and an early removal has left more room for relaxation so that it could not be back-filled again.
Since (b) does not have any time coherence, we can conclude that it has not converged on one placement at the 1500-step mark,
as the result of two of its executions is different.
While this effect also exists in our implementation, it is essentially neutralized by the temporal weight, thus producing matching lines.
% \[, \hspace{7mm} u_2(x,y,t)=(1,t), \hspace{7mm} u_3(x,y,t)=(-x-t, -y-t)\]
% As a baseline case, we show the placement for $u_1$ and $u_2$ in \Cref{fig:trivialresults1} and \Cref{fig:trivialresults2}.

\newpage

\begin{figure}[ht]
    \centering
    \begin{subfigure}{\textwidth}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/DiagLines.png}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/DiagTB.png}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/DiagConst.png}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/DiagOurs.png}
            \caption{}
        \end{subfigure}
    \end{subfigure}
    \caption{
        Streamline placement for $u(x,y,t)=(1,t)^T$.
        (a) $u$ at $t=-1$.
        (b) $u$ at $t=-0.5$, base algorithm.
        (c) $u$ at $t=-0.5$, constant seeds.
        (d) $u$ at $t=-0.5$, our implementation.
    }
    \label[figure]{fig:trivialresults2}
\end{figure}
\begin{figure}[ht]
    \centering
    \begin{subfigure}{\textwidth}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/DiagLines.png}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/DiagTB2.png}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/DiagConst2.png}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/DiagOurs2.png}
            \caption{}
        \end{subfigure}
    \end{subfigure}
    \caption{
        Streamline placement for $u(x,y,t)=(1,t)^T$.
        (a) $u$ at $t=-1$.
        (b) $u$ at $t=0.75$, base algorithm.
        (c) $u$ at $t=0.75$, constant seeds.
        (d) $u$ at $t=0.75$, our implementation.
    }
    \label[figure]{fig:trivialresults22}
\end{figure}

The second case uses a field with a rotating set of parallel streamlines defined as $u_2(x,y,t)=(1,t)^T$, which is seen in \Cref{fig:trivialresults2} and \Cref{fig:trivialresults22}.
Due to the nature of this field, time coherence is difficult to achieve consistently along the entire line.
Hence, the only useful measure is the spatial energy, and all three algorithms generate images with a uniform spatial distribution of streamlines.
This shows that our implementation can effectively deal with this case too when choosing $\alpha$ accordingly,
as stated at the beginning of this chapter, allowing $E_s$ to take over when $E_t$ cannot produce a consistent bias.

The case where $t=0.75$ in \Cref{fig:trivialresults22} makes algorithms relying too much on the seed placement perform badly.
We can see how the constant algorithm in (c) tries to rectify the high spatial
energy by shortening the streamlines, as it cannot move the seeds apart.

Our algorithm is able to mitigate such effects due to allowing sufficient relaxation for the streamlines created from the individual shards.
Since we only allow new lines to be created from seeds obtained during the shatter process when they improve the image,
the effect of ``over-seeding'' as seen in (c) is avoided.

\newpage

\begin{figure}[ht]
    \centering
    \begin{subfigure}{\textwidth}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/Sink.png}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/SinkTB.png}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/SinkConst.png}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/SinkOurs.png}
        \end{subfigure}
    \end{subfigure}
    \begin{subfigure}{\textwidth}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/SinkLines.png}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/SinkTBLines.png}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/SinkConstLines.png}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Trivial/SinkOursLines.png}
            \caption{}
        \end{subfigure}
    \end{subfigure}
    \caption{
        Streamline placement for $u(x,y,t)=(-x-t, -y-t)^T$.
        (a) $u$ at $t=0$.
        (b) $u$ at $t=0.05$, base algorithm.
        (c) $u$ at $t=0.05$, constant seeds.
        (d) $u$ at $t=0.05$, our implementation.
    }
    \label[figure]{fig:trivialresults3}
\end{figure}

For the last trivial case, we look at the sink defined by $u_3(x, y, t) = (- x - t, - y - t)$ in \Cref{fig:trivialresults3}.
The base algorithm (b) places its streamlines with good spatial uniformity, but very little overlap between the frames.
While streamlines from the constant algorithm (c) exhibit better coherence, their spatial quality quickly decays.
Our implementation (d) creates evenly spaced streamlines as well,
and behaves similar in terms of placement to (c) due to the shatter process.

\newpage

\subsection{More complex Fields}

\begin{figure}[ht]
    \centering
    \begin{subfigure}{\textwidth}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Medium/Waves.png}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Medium/WavesTB.png}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Medium/WavesConst.png}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Medium/WavesOurs.png}
            \caption{}
        \end{subfigure}
    \end{subfigure}
    \caption{
        Streamline placement for $u_1(x,y,t)=(1, \sin(x)t)^T$.
        Seeds are drawn in magenta.
        (a) $u$ at $t=1$.
        (b) $u$ at $t=1.25$, base algorithm.
        (c) $u$ at $t=1.25$, constant algorithm.
        (d) $u$ at $t=1.25$, our implementation.
    }
    \label[figure]{fig:reswaves}
\end{figure}

We now look at some more interesting cases allowing for stronger differences in temporal and spatial placement quality.
The first field in \Cref{fig:reswaves} uses a sine pattern defined by $u_1(x,y,t)=(1, \sin(x)t)^T$.
Here, we can see slight reduction in image quality for our implementation (c) compared to the base algorithm (b), as ours
produces a gap in the top half.
We note a strong similarity between (c) and (d) because
our algorithm favors the time coherence provided by the curved regions in the center and near the edges,
as opposed to the straight sections between them.
Coherence is therefore focused on the curved regions, as the overlap is simply higher.
Furthermore, when compared with the image from the motivation in \Cref{fig:necessary2},
we see that we have reached the case we wanted to avoid at first.
This is expected, because the algorithm can no longer determine
which change to consider the ``local'' one since we do not have the stationary sections on the sides.

\newpage

\begin{figure}[ht]
    \centering
    \begin{subfigure}{\textwidth}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Medium/Gyro.png}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Medium/GyroTB.png}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Medium/GyroConst.png}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Medium/GyroOurs.png}
        \end{subfigure}
    \end{subfigure}
    \begin{subfigure}{\textwidth}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Medium/GyroLines.png}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Medium/GyroTBOverlay.png}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Medium/GyroConstOverlay.png}
            \caption{}
        \end{subfigure}
        \begin{subfigure}{.24\textwidth}
            \centering
            \includegraphics[scale=.06]{figures/Results/Medium/GyroOursOverlay.png}
            \caption{}
        \end{subfigure}
    \end{subfigure}
    \caption{
        Streamline placement for the double gyre.
        The first row shows the footprints, the second row the lines for visual clarity, with the red lines being
        the starting frame (a), and the black lines the respective algorithm's placement.
        (a) base case, with vortices at 70\% image height.
        (b) vortices at 65\% image height, base algorithm.
        (c) vortices at 65\% image height, constant algorithm.
        (d) vortices at 65\% image height, our algorithm.
    }
    \label[figure]{fig:resgyro}
\end{figure}

As the second medium complexity case, we show the double gyre with a slightly different movement pattern.
Moving both centers downward instead of just one allows for better time coherence as the field does not
undergo a rotation but rather a downward translation.
The lower row in \Cref{fig:resgyro} clearly shows how (c) and (d) perform significantly better than (b),
with (c) exhibiting very inconsistent line spacing. Our implementation handles this case better,
with deviation from the previous frame only noticeable at the gyre centers, which is expected since
they produce the strongest field distortion when moved over time.

\newpage

\input{Sources/HotRoom.tex}


\section{Performance}
The algorithm was run on a system with the following relevant hardware.
CPU: AMD Ryzen 5 5600X 3.70 GHz, RAM: 16 GB DDR4 ($\approx$ 400 MB used by ParaView).
Most of the images with a black background color were generated in about 3-4 minutes each.
Images from the HotRoom dataset took about 13 minutes per frame
when using coaxing (and half the time otherwise) due to the convolution with two filters being twice as expensive.
For comparison, the initial greedy algorithm took about 10 seconds.
The size of the low pass image is of little to no importance for speed, we tested filter radii between 2 and 32,
both of which took about the same time to complete.

\newpage
\section{Limitations and Possibilities for Future Work}
\paragraph*{Restriction to 2D}
An obvious constraint is the restriction to two-dimensional data.
This is a result of the image-guided nature from Turk and Banks' algorithm,
as its principle only makes sense with a ``bird's eye'' view onto the line image.
Extending this principle into 3D could be done by extracting a view-dependent surface,
and then using the algorithm on that surface. 

\paragraph*{Sensitivity to Field Changes}
Another important aspect is the sensitivity of the algorithm regarding $\alpha$
and the distance lines move from one time step to the next.
If this distance is too large, high $\alpha$ values will quickly lead to degradation
of image quality due to the high coherence weight.
This can be counteracted by using more fine-grained interpolation of the field movement,
or reducing $\alpha$ to allow the lines to move and relax more freely.

\paragraph*{Adaptive Choice of $\alpha$ and $r_t$}
The coherence weight parameter is configurable prior to a run,
but for different datasets (or even different frames) it should prove useful to vary this parameter.
This could perhaps be added via an adaptive method
that generates $n$ line placements for the next frame using different $\alpha$ and $r_t$ values.
It then moves $\alpha$ and $r_t$ closer to the parameters
from the image causing the least amount of relative energy fluctuation.
Of course, this would increase the computational cost by a factor of $n$, but potentially
allows more effective automation by removing the need for fine-tuning in some cases.

\paragraph*{Memory Usage}
Memory usage scales with the low pass size and line count,
as every line saves its contributions to the energy as an array of the same size.
When using large amounts of lines with a high low-pass resolution,
memory usage grows $O(n\cdot m)$, with $n$ being the number of lines and $m$ the image pixel count.
% We found that the low-pass resolution has very little effect on the resulting line placement, we used the 120x120 resolution solely for a smoother appearance.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%