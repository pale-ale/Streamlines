%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This chapter briefly mentions the used libraries, and focuses on the initial implementation of - and iterative additions to - the proposed algorithm.
\section{Libraries}
The algorithm is implemented in python3.10, and heavily relies on three libraries which are not part of the python3.10 standard library:
\begin{itemize}
    \item Paraview v.5.12.0: A Scientific visualization software, combining data science and interactive visualization while providing custom algorithm support via the VtkPythonAlgorithm base class.
    \item VTK v.9.3.20231030 : The library used to manage anything related with the data to be visualized in Paraview.
    \item Numpy v.1.23.4: Widespread data manipulation/scientific computing library, which is used to edit the data encapsulated by VTK's objects.
\end{itemize}

\section{Steady Field Streamline Placement in 2D}
We start with a simple algorithm to generate streamlines in a 2D slice of a vector field.
The local z-component of the Cartesian grid is simply set to zero for the relevant sections of the algorithm.
The algorithm uses two operations: Streamline Traversal and Seed Filtering, which are executed round-robin.
\subsection{Streamline Tarversal}
The Streamline Traversal process works as follows:
\begin{itemize}
    \begin{minipage}{.6\textwidth}
    \item \textbf{Step 1:}
    Choose a seed point from a list of candidates (initially an arbitrary point from the dataset) and remove it from the list.
    Then integrate forward and backward to obtain the other points on the streamline, until
    a number of steps is reached, we cross the bounding box, or we get too close to another streamline.
    \item \textbf{Step 2:}
    Compute the normals, add and subtract them to the succeeding point. The first point (according to step count in backward iteration) will not have a preceding normal, and is not used in this step. These points are new seed candidates for further streamline placement.
    \end{minipage}
    \begin{minipage}{.3\textwidth}
    \input{Sources/Diagrams/Implementation1}
    \end{minipage}
\end{itemize}
\subsection{Seed Filtering}
Since after the 1st iteration, roughly half of the points added by step 2 will be very close to the preceding iteration's points, we store the parent's points and remove any new points from the current step if they are too close to the parent's points.
Furthermore, a grid is used to track the global state of the field w.r.t to lines existing in individual segments.
This is used to determine whether a line is getting too close to another or if it has room to expand. Streamlines are removed if their length is shorter than 10 iteration steps.
\section{Steady Field Streamline Placement in 3D}
Instead of the trivial normal(s), we now use a normal plane around the streamline trajectory, created via numpy's QR-decomposition. The algorithm returns orthonormalized vectors, the first column vector's direction being equal to the first provided input vector.
We can therefore feed it the streamline trajectory and two basis vectors, and receive 2 orthonormal basis vectors $b_0, b_1$.\\
With $i$ being the complex number, we obtain $k$ roots of unity via \[n_j = e^{ji2\pi/k}, j = 0, 1, ..., k-1\]
We then transform them into our 3D frame of reference using \[v_i = re(n_i)*b_0 + im(n_i)*b_1 \] This gives us $k$ uniformly placed  vectors in the normal plane around the current streamline segment. The rest of the algorithm stays largely the same, the grid is simply extended into the 3rd dimension.
\section{Unsteady Field Streamline Placement in 3D}
\newpage
\section{Complexity Analysis}
% We have:
% \begin{itemize}
%     \item the iteration count $I$, corresponding to the maximum number of lines
%     \item a max integration step count $S$
%     \item a neighbor count $N$
%     \item a minimum neighbor distance (or cell size) $D$
%     \item a dictionary of size up to $quadx * quady * quadz / D^3$
% \end{itemize}
% Creating a streamline performs the following operations:\\
% - Iterate forward and backward: $2S$\\
% - For each iteration step, we obtain $N$ seed candidates, so $2SN$ candidates total\\
% - For each iteration step, check via dict if the new position lies in a grid cell already occupied: $O(N\cdot1)$\\\\
% \noindent
% Creating a streamline therefore comes with a complexity of $O(2S + 2SN + 1) = O(2SN)$.
% Since each line generates $O(2SN)$ seeds, and we create $I$ lines, the amount of seeds grows with $I\cdot O(2SN)$.
% Typical values for small datasets would be $I=1000$, $S=200, N=3$, giving us roughly 1.2 Million seed candidates.