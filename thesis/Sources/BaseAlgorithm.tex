\section{The Base Algorithm}

In this chapter, we introduce the image-guided streamline placement algorithm developed by turk and banks.

\subsection{Energy Measure}
The method used by Turk and Banks defines three important components to measure image quality as the sum of deviations of a low-pass image from a uniform greyscale target.
\begin{enumerate}
    \item The first component is a collection of (straight) line segments from each line,
    each of which can be converted to a line formula of the form $p = start + (end - start) * c$.
    The formula is then evaluated to obtain points as pixels where the low-pass filter in the 2nd listing is applied.
    In their paper, they call the implicit image obtained from the line segments' footprint $I$.
    \begin{equation*}
        I(x,y) = \begin{cases}
            1, \kern4em & \text{pixel lies on line}\\
            0,          & \text{else}
    \end{cases}
    \end{equation*}
    
    \item The second component is the low-pass filter $L$.
    It uses a kernel to generate the filtered image of a line.
    Given a falloff distance $R$ and $r=\sqrt{x^2+y^2} / R$, the kernel is defined as:
    \begin{equation*}
        K(x,y) = \begin{cases}
            2r^3 - 3r^2 + 1, \kern4em & r < 1\\
            0,               & r >= 1
        \end{cases}
    \end{equation*}
    For every pixel a line passes through, this kernel is applied additively, with its origin centered on the pixel containing the line.
    When applied consecutively along a line segment, the kernel will overlap and produce numbers from 1 to $2R$ for pixels close to the line.
    
    \item In order to determine the energy of the image generated by the kernel application, the following expression is used:
    \begin{equation*}
        E(I) = \int_x\int_y\left[(L\ast I)(x,y)-t\right]^2\,dx\,dy
    \end{equation*}
    With $t$ referring to the \textit{target brightness}, in their source code the number one is used.
\end{enumerate}
It is pivotal for this energy measure to react to nigh-nonexistent changes for the algorithm to successfully converge.
Therefore, this algorithm does \textit{not} use a simple rasterization and blur technique, as the initial discretization/rasterization
of the line would remove too much information, even when using anti-aliasing or other enhancing techniques.
While we discuss the actual implementation in chapter 5, the takeaway here is that the line remains in its analytical form as segments between points.
Then, every point inside the bounding box around every line segment calculates its brightness based on the line equation, not by simply blurring pixels on the line.

\subsection{Our Adaptation}
\noindent Our implementation works similarly, except that instead of the cubic Hermite filter, we use a two-dimensional Gauss filter.
We also use the distance $R$ as the radius of the filter, and calculate a small segment of a straight line in order to determine
how the brightness of the filter should be scaled to reach $1.5t$, so that we do not have to deal with differences depending on integration step size. 
More precisely, given the radius $R$ and filter diameter $D=2R+1$, we define a line footprint $A \in \mathbb{R}^{D\times D}$:
\begin{equation*}
    A_{x,y} = \begin{cases}
        1, \kern4em & x = R\\
        0, \kern4em & \text{otherwise}
    \end{cases}
\end{equation*}
We then apply our filter with $\sigma = R/3$, and use $1.5t  / A_{[R,R]}$ as our filter scale $s$, (in our case $t=1$).
Having obtained the filter scale, we can now compute the filtered image $L\ast I$ as $L\ast I = s \cdot Gauss(I, \sigma, R)$.
The computation of $E(I)$ is otherwise identical.

\subsection{Randomized Optimizations}
Turk and Banks define six actions:
\begin{itemize}
    \item \textbf{Insert, Delete:} Add or remove a line from the image.
    \item \textbf{Lengthen, Shorten:} In-/Decrease the length of a line on one or both ends.
    \item \textbf{Combine:} Join two lines head-to-tail.
    \item \textbf{Move:} Translate the seed of a line by a small distance.
\end{itemize}
These actions are selected randomly with random parameters, then applied to a random line.
The algorithm terminates after an energy range was reached, or accepted changes become rare enough to not introduce changes anymore.\\
\begin{minipage}{.55\textwidth}
    \vspace{5pt}
    If the change was deemed beneficial according to a decrease in energy, it is accepted, otherwise the changes are reverted.
    This causes a "drift" of the lines toward a more uniform energy level.
    Naturally, this depends heavily on the choice of $t$. If $t$ were to be chosen closer to 2,
    the image would become very crowded to reach the increased target gray level.
    \vspace{5pt}
\end{minipage}
\begin{minipage}{.45\textwidth}
    \begin{center}
        \includegraphics*{figures/SL_bump1.png}
        \captionof{figure}{A line (green) being shifted away from an existing one (black)}
    \end{center}
    \vspace*{5pt}
\end{minipage}